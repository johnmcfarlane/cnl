<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CNL: User Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="cnl.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CNL
   &#160;<span id="projectnumber">2.0.2 (development)</span>
   </div>
   <div id="projectbrief">Compositional Numeric Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<p>The Compositional Numeric Library (CNL) is a C++ library of fixed-precision numeric classes which enhance integers to deliver safer, simpler, cheaper arithmetic types.</p>
<p>CNL improves on numbers the same way that the STL improves on arrays and smart pointers improve on pointers.</p>
<p>Uses include</p><ul>
<li>simulations that rely on precision, determinism, and predictability,</li>
<li>financial applications handling decimal fractions and</li>
<li>resource-critical systems where floating-point arithmetic is too costly.</li>
</ul>
<p>The CNL project is published under the Boost licence and can be found online at <a href="https://github.com/johnmcfarlane/cnl">github.com/johnmcfarlane/cnl</a>.</p>
<h1><a class="anchor" id="Components"></a>
Components</h1>
<h2><a class="anchor" id="Core_Components"></a>
Core Components</h2>
<p>The core numeric types of CNL are:</p><ul>
<li><a class="el" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">scaled_integer</a> - scales integers by any exponent and base with zero-overhead and minimal precision loss;</li>
<li><a class="el" href="namespacecnl.html#ae512c45c8ddb3ca1289c9600fa6ca343">elastic_integer</a> - prevents overflow at compile-time by generalizing promotion rules;</li>
<li><a class="el" href="namespacecnl.html#ac34ccb6019b31f3e21b69a415cfd26c1">overflow_integer</a> - handles integer overflow at runtime;</li>
<li><a class="el" href="namespacecnl.html#a597dddac44319df1e4d641d21c195792">rounding_integer</a> - improves rounding behavior of integers;</li>
<li><a class="el" href="namespacecnl.html#ad0668c01efc630f5ecd1bdc7b991c3cb">wide_integer</a> - provides integers wider than 64 and 128 bits using multi-word arithmetic;</li>
<li><a class="el" href="structcnl_1_1fraction.html">fraction</a> - low-level dividend/divisor pair aids refined division handling and</li>
<li><a class="el" href="structcnl_1_1constant.html">constant</a> - a numerics-friendly alternative to <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>.</li>
</ul>
<p>Each of these types solves a single problem when used alone.</p>
<h2><a class="anchor" id="Composite_Types"></a>
Composite Types</h2>
<p>In combination, the core types produce composites which address multiple concerns.</p>
<p>Provided composite types include:</p><ul>
<li><a class="el" href="namespacecnl.html#aae6e40278eb7ebee1c82a01c43a7bd7e">elastic_scaled_integer</a> (<a class="el" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">scaled_integer</a> and <a class="el" href="namespacecnl.html#ae512c45c8ddb3ca1289c9600fa6ca343">elastic_integer</a>) - real-number approximation which uses promotion to avoid overflow;</li>
<li><a class="el" href="namespacecnl.html#ab84979e9c09ff27d096f3addae74c20d">static_integer</a> (<a class="el" href="namespacecnl.html#a597dddac44319df1e4d641d21c195792">rounding_integer</a>, <a class="el" href="namespacecnl.html#ac34ccb6019b31f3e21b69a415cfd26c1">overflow_integer</a>, <a class="el" href="namespacecnl.html#ae512c45c8ddb3ca1289c9600fa6ca343">elastic_integer</a> and <a class="el" href="namespacecnl.html#ad0668c01efc630f5ecd1bdc7b991c3cb">wide_integer</a>) - fully-featured safe, accurate integer type and</li>
<li><a class="el" href="namespacecnl.html#a60d1f9a1c93a501bef14e46ce587fb9e">static_number</a> (<a class="el" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">scaled_integer</a> and <a class="el" href="namespacecnl.html#ab84979e9c09ff27d096f3addae74c20d">static_integer</a>) - a fully-featured safe, accurate real number approximation.</li>
</ul>
<p>Many more combinations are possible. For example:</p><ul>
<li><code>safe_integer</code> (<a class="el" href="namespacecnl.html#ac34ccb6019b31f3e21b69a415cfd26c1">overflow_integer</a> and <a class="el" href="namespacecnl.html#ae512c45c8ddb3ca1289c9600fa6ca343">elastic_integer</a>);</li>
<li><code>wide_elastic_integer</code> (<a class="el" href="namespacecnl.html#ae512c45c8ddb3ca1289c9600fa6ca343">elastic_integer</a> and <a class="el" href="namespacecnl.html#ad0668c01efc630f5ecd1bdc7b991c3cb">wide_integer</a>) and</li>
<li><code>safe_fraction</code> (<a class="el" href="structcnl_1_1fraction.html">fraction</a> and <code>safe_integer</code>).</li>
</ul>
<h1><a class="anchor" id="Examples"></a>
Examples</h1>
<p>The following examples can be found in the <a href="../../test/unit/index.cpp">test suite</a>.</p>
<h2><a class="anchor" id="Declaration"></a>
Declaration</h2>
<p>The <a class="el" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">scaled_integer</a> type adds a scaling exponent to integers. This enables the integer to represent very big or very small values.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="all_8h.html">cnl/all.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> <a class="code" href="structcnl_1_1power.html">cnl::power</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">cnl::scaled_integer</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> declaration_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// x is represented by an int and scaled down by 1 bit</span></div>
<div class="line">    <span class="keyword">auto</span> x = <a class="code" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">scaled_integer</a>&lt;int, power&lt;-1&gt;&gt;{3.5};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// under the hood, x stores a whole number</span></div>
<div class="line">    <a class="codeRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">cout</a> &lt;&lt; to_rep(x) &lt;&lt; <a class="codeRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">endl</a>;  <span class="comment">// &quot;7&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// but it multiplies that whole number by 2^-1 to produce a real number</span></div>
<div class="line">    <a class="codeRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">cout</a> &lt;&lt; x &lt;&lt; <a class="codeRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">endl</a>;  <span class="comment">// &quot;3.5&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// like an int, x has limited precision</span></div>
<div class="line">    x /= 2;</div>
<div class="line">    <a class="codeRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">cout</a> &lt;&lt; x &lt;&lt; <a class="codeRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">endl</a>;  <span class="comment">// &quot;1.5&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="Arithmetic_Operators"></a>
Arithmetic Operators</h2>
<p>Specializations of <a class="el" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">scaled_integer</a> behave a lot like native C/C++ numeric types. Operators are designed to behave in an way which is both predictable and efficient.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> basic_arithmetic_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// define a constant signed value with 3 integer and 28 fraction bits (s3:28)</span></div>
<div class="line">    <span class="keyword">auto</span> pi = <a class="code" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">scaled_integer</a>&lt;int32_t, power&lt;-28&gt;&gt;{3.1415926535};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// expressions involving integers return scaled_integer results</span></div>
<div class="line">    <span class="keyword">auto</span> tau = pi * 2;</div>
<div class="line">    static_assert(is_same&lt;decltype(tau), <a class="code" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">scaled_integer</a>&lt;int32_t, power&lt;-28&gt;&gt;&gt;::value);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;6.28319&quot;</span></div>
<div class="line">    cout &lt;&lt; tau &lt;&lt; <a class="codeRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">endl</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// expressions involving floating-point values return floating-point results</span></div>
<div class="line">    <span class="keyword">auto</span> degrees = tau * (180 / 3.1415926534);</div>
<div class="line">    static_assert(is_same&lt;decltype(degrees), <span class="keywordtype">double</span>&gt;::value);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;360&quot;</span></div>
<div class="line">    cout &lt;&lt; degrees &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="Arithmetic_Functions"></a>
Arithmetic Functions</h2>
<p>But one size does not fit all. Different applications of the same operation might call for different trade-offs between storage, precision, safety and speed. Named functions provide fine-tuned control over arithmetic results.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="namespacecnl.html#aae6e40278eb7ebee1c82a01c43a7bd7e">cnl::elastic_scaled_integer</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> advanced_arithmetic_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// this variable uses all of its capacity</span></div>
<div class="line">    <span class="keyword">auto</span> x = <a class="code" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">scaled_integer</a>&lt;uint8_t, power&lt;-4&gt;&gt;{15.9375};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 15.9375 * 15.9375 = 254.00390625 ... overflow!</span></div>
<div class="line">    <span class="keyword">auto</span> xx1 = <a class="code" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">scaled_integer</a>&lt;uint8_t, power&lt;-4&gt;&gt;{x * x};</div>
<div class="line">    cout &lt;&lt; xx1 &lt;&lt; <a class="codeRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">endl</a>;  <span class="comment">// &quot;14&quot; instead!</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// fixed-point multiplication operator obeys usual promotion and implicit conversion rules</span></div>
<div class="line">    <span class="keyword">auto</span> xx = x * x;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// x*x is promoted to scaled_integer&lt;int, -8&gt;</span></div>
<div class="line">    static_assert(is_same&lt;decltype(xx), <a class="code" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">scaled_integer</a>&lt;<span class="keywordtype">int</span>, power&lt;-8&gt;&gt;&gt;::value);</div>
<div class="line">    cout &lt;&lt; xx &lt;&lt; <a class="codeRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">endl</a>;  <span class="comment">// &quot;254.00390625&quot; - correct</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// you can avoid the pitfalls of integer promotion for good by using the elastic_scaled_integer</span></div>
<div class="line">    <span class="comment">// type</span></div>
<div class="line">    <span class="keyword">auto</span> named_xx = <a class="code" href="namespacecnl.html#a9c08b06a540e15fb300a460ce7a018a6">make_elastic_scaled_integer</a>(x) * <a class="code" href="namespacecnl.html#a9c08b06a540e15fb300a460ce7a018a6">make_elastic_scaled_integer</a>(x);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// this type tracks both the number of digits and the exponent to ensure lossless multiplication</span></div>
<div class="line">    static_assert(is_same&lt;decltype(named_xx), <a class="code" href="namespacecnl.html#aae6e40278eb7ebee1c82a01c43a7bd7e">elastic_scaled_integer</a>&lt;16, power&lt;-8&gt;, <span class="keywordtype">unsigned</span>&gt;&gt;::value);</div>
<div class="line">    cout &lt;&lt; named_xx &lt;&lt; <a class="codeRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">endl</a>;  <span class="comment">// &quot;254.00390625&quot; - also correct but prone to overflow</span></div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="Extensible"></a>
Extensible</h2>
<p>Because one size does not fit all, <a class="el" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">scaled_integer</a> is designed to make it easy to tailor new arithmetic types. The <a class="el" href="namespacecnl.html#aae6e40278eb7ebee1c82a01c43a7bd7e">elastic_scaled_integer</a> type illustrates this. As each calculation requires more digits, so the results of <a class="el" href="namespacecnl.html#aae6e40278eb7ebee1c82a01c43a7bd7e">elastic_scaled_integer</a> operations allocate more storage.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="namespacecnl.html#ae512c45c8ddb3ca1289c9600fa6ca343">cnl::elastic_integer</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> elastic_example1()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Consider an integer type which keeps count of the bits that it uses.</span></div>
<div class="line">    <span class="keyword">auto</span> a = elastic_integer&lt;6, int8_t&gt;{63};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Results of its operations widen as required.</span></div>
<div class="line">    [[maybe_unused]] <span class="keyword">auto</span> aa = a * a;</div>
<div class="line">    static_assert(is_same&lt;decltype(aa), elastic_integer&lt;12, int8_t&gt;&gt;::value);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Obviously, this type no longer fits in a byte.</span></div>
<div class="line">    static_assert(<span class="keyword">sizeof</span>(aa) == 2);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Addition requires smaller results.</span></div>
<div class="line">    [[maybe_unused]] <span class="keyword">auto</span> a2 = a + a;</div>
<div class="line">    static_assert(is_same&lt;decltype(a2), elastic_integer&lt;7, int8_t&gt;&gt;::value);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> <a class="code" href="namespacecnl.html#aae6e40278eb7ebee1c82a01c43a7bd7e">cnl::elastic_scaled_integer</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> elastic_example2()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// A type such as elastic_integer can be used to specialize scaled_integer.</span></div>
<div class="line">    <span class="comment">// Now arithmetic operations are more efficient and less error-prone.</span></div>
<div class="line">    <span class="keyword">auto</span> b = <a class="code" href="namespacecnl.html#aae6e40278eb7ebee1c82a01c43a7bd7e">elastic_scaled_integer</a>&lt;31, power&lt;-27&gt;, <span class="keywordtype">unsigned</span>&gt;{15.9375};</div>
<div class="line">    <span class="keyword">auto</span> bb = b * b;</div>
<div class="line"> </div>
<div class="line">    cout &lt;&lt; bb &lt;&lt; <a class="codeRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">endl</a>;  <span class="comment">// &quot;254.00390625&quot;</span></div>
<div class="line">    static_assert(is_same&lt;decltype(bb), <a class="code" href="namespacecnl.html#aae6e40278eb7ebee1c82a01c43a7bd7e">elastic_scaled_integer</a>&lt;62, power&lt;-54&gt;, <span class="keywordtype">unsigned</span>&gt;&gt;::value);</div>
<div class="line">}</div>
</div><!-- fragment --> <h1><a class="anchor" id="FAQ"></a>
FAQ</h1>
<h2><a class="anchor" id="overflow"></a>
Fixed-point Overflow</h2>
<p><b>Q:</b> Why do calculations using <a class="el" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">cnl::scaled_integer</a> result in completely wrong results?</p>
<p><b>A:</b> Most surprises reported by CNL users occur when a <a class="el" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">cnl::scaled_integer</a> value exceeds the range that its type can represent. This is normally caused by arithmetic operations (especially multiplication) and from conversion between different scales. It typically results in 'modulo' or overflow behavior.</p>
<p>Consider the multiplication of 1*1. What could possibly go wrong?</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> overflow_example1()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// fixed-point value of 65,536 * 2^-16</span></div>
<div class="line">    <span class="keyword">auto</span> num = <a class="code" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">cnl::scaled_integer</a>&lt;int, <a class="code" href="structcnl_1_1power.html">cnl::power</a>&lt;-16&gt;&gt;{1};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// fixed-point value of 4,294,967,296 * 2^-32</span></div>
<div class="line">    <span class="keyword">auto</span> square = num * num;</div>
<div class="line"> </div>
<div class="line">    <a class="codeRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; square;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="el" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">cnl::scaled_integer</a> does nothing more here than perform integer multiplication. But the product is too great to be stored in an <code>int</code> (on a typical system). Here is the equivalent operation being performed directly on the <code>int</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> overflow_example2()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// integer variable with value 65,536</span></div>
<div class="line">    <span class="keyword">auto</span> num = 65536;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// integer variable with value 4,294,967,296</span></div>
<div class="line">    <span class="keyword">auto</span> square = num * num;</div>
<div class="line"> </div>
<div class="line">    <a class="codeRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; square;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This value is too great to be stored in a 32-bit integer. In both cases overflow will occur and the result will not be valid.</p>
<p><b>Q:</b> Why do calculations using <a class="el" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">cnl::scaled_integer</a> result in a <code>static_assert</code> error?</p>
<p>Errors with the message "attempted operation will result in overflow" may be the result of conversion between types whose ranges do not intersect as described above. For example, when converting from a 32-bit <a class="el" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">cnl::scaled_integer</a> to a 64-bit <a class="el" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">cnl::scaled_integer</a>, you may find that the 32-bit number is being scaled up or down by 32 bits before being converted to 64-bits. This would result in overflow. Read on for suggested solutions...</p>
<p><b>Q:</b> Why doesn't <a class="el" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">cnl::scaled_integer</a> prevent/avoid/detect overflow?</p>
<p><b>A:</b> CNL provides a library of components which each address a single concern. The concern of <a class="el" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">cnl::scaled_integer</a> is the approximation of real numbers with integers. It does this as efficiently as the chosen integer type allows. In the case of <code>int</code>, this is very efficient, but without safety checks.</p>
<p>There are several solutions with different tradeoffs including:</p><ul>
<li>sanitizers, which can detect many such errors at runtime (<a href="https://godbolt.org/z/GdY6ce">example</a>);</li>
<li>replace <code>int</code> with <a class="el" href="namespacecnl.html#ac34ccb6019b31f3e21b69a415cfd26c1">cnl::overflow_integer</a> to detect all such errors at runtime (<a href="https://godbolt.org/z/sx3bvc">example</a>);</li>
<li>replace <code>int</code> with <a class="el" href="namespacecnl.html#ae512c45c8ddb3ca1289c9600fa6ca343">cnl::elastic_integer</a> to avoid many such errors at compile-time (<a href="https://godbolt.org/z/Knfn39">example</a>);</li>
<li>consider other <a class="el" href="index.html#Composite_Types">Composite Types </a> to find a good balance between efficiency, safety and correctness.</li>
</ul>
<p><b>Q:</b> Why do some overflow errors only show up / not show up at run-time?</p>
<p><b>A:</b> The preferred methods for signaling overflow errors are by trapping them and halting the program, by invoking undefined behavior (UB), or the combination of trapping UB (using a sanitizer). Trapping inevitably has to occur at run-time because the compiler cannot possibly know all the values that a program might compute...</p>
<p>...except when an expression is evaluated at compile time, e.g. a <code>constexpr</code> value. Such an evaluate is not allowed to exhibit UB, and therefore the compiler (helpfully) rejects it.</p>
<p>In the case where CNL is configured to not signal overflow, overflow may go undetected. And further, in the case that the overflow is UB, the program is defective and <b>must</b> be fixed.</p>
<h2><a class="anchor" id="division"></a>
Fixed-point Division</h2>
<p><b>Q:</b> Why aren't the results of <a class="el" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">cnl::scaled_integer</a> division more precise?</p>
<p><b>A:</b> Integer and floating-point division are fundamentally different. Being integer-based, <a class="el" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">cnl::scaled_integer</a> uses integer division in its '<code>/</code>' operator.</p>
<p>This is surprising to users who expect fixed-point types to behave like floating-point types. But the floating-point '<code>/</code>' operator returns results with a variable exponent — something a fixed-point type cannot do.</p>
<p>In comparison, the integer '<code>/</code>' operator yields an integer quotient while the '<code>%</code>' operator provides the remainder. This gives lossless results, provided the remainder is taken into account. Integer division is more efficient and more versatile. It's also more intuitive for applications involving discrete values, such as denominations:</p>
<div class="fragment"><div class="line">    <span class="comment">// The _cnl suffix prevents decimal rounding errors.</span></div>
<div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespacecnl_1_1literals.html">cnl::literals</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Euros have subunits of 100^-1</span></div>
<div class="line">    <span class="keyword">using</span> euros = <a class="code" href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">scaled_integer</a>&lt;int, power&lt;-1, 100&gt;&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> funds{euros{5.00_cnl}};</div>
<div class="line">    <span class="keyword">auto</span> candle_price{euros{1.10_cnl}};</div>
<div class="line"> </div>
<div class="line">    <a class="codeRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">cout</a> &lt;&lt; <span class="stringliteral">&quot;Q: If I have €&quot;</span> &lt;&lt; funds</div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot; and candles cost €&quot;</span> &lt;&lt; candle_price</div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot;, how many candles can I buy?\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 5.00 / 1.10 = 4</span></div>
<div class="line">    <span class="keyword">auto</span> num_candles{funds / candle_price};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 5.00 % 1.10 = 0.60</span></div>
<div class="line">    <span class="keyword">auto</span> change{funds % candle_price};</div>
<div class="line"> </div>
<div class="line">    <a class="codeRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">cout</a> &lt;&lt; <span class="stringliteral">&quot;A: I get &quot;</span></div>
<div class="line">         &lt;&lt; num_candles &lt;&lt; <span class="stringliteral">&quot; candles and €&quot;</span></div>
<div class="line">         &lt;&lt; change &lt;&lt; <span class="stringliteral">&quot; change.\n&quot;</span>;</div>
</div><!-- fragment --><p> Output:</p>
<blockquote class="doxtable">
<p>Q: If I have €5 and candles cost €1.1, how many candles can I buy?<br  />
A: I get 4 candles and €.6 change. </p>
</blockquote>
<p>You can read more on the subject in the paper, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1368r1.html">Multiplication and division of fixed-point numbers</a> by Davis Herring.</p>
<p><b>Q:</b> OK, but what if I'm dealing with continuous values?</p>
<p><b>A:</b> For now, divide numbers using the <a class="el" href="namespacecnl.html#a047c0ddbae64bc80b4ca5af0c3ffaae2">cnl::quotient</a> API, which makes a best guess about the exponent you want, or consider avoiding division altogether by using the <a class="el" href="structcnl_1_1fraction.html">cnl::fraction</a> type.</p>
<p>Due to popular demand an alternative fixed-point type, which implements 'quasi-exact' division is planned for a future revision of the library.</p>
<h2><a class="anchor" id="limits"></a>
Elastic Limits</h2>
<p><b>Q:</b> Why doesn't the <code>Digits</code> parameter of types such as <a class="el" href="namespacecnl.html#ae512c45c8ddb3ca1289c9600fa6ca343">cnl::elastic_integer</a> include the 'sign' bit?</p>
<p><b>A:</b> Types, <a class="el" href="namespacecnl.html#ae512c45c8ddb3ca1289c9600fa6ca343">cnl::elastic_integer</a>, <a class="el" href="namespacecnl.html#aae6e40278eb7ebee1c82a01c43a7bd7e">cnl::elastic_scaled_integer</a>, <a class="el" href="namespacecnl.html#ab84979e9c09ff27d096f3addae74c20d">cnl::static_integer</a> and <a class="el" href="namespacecnl.html#a60d1f9a1c93a501bef14e46ce587fb9e">cnl::static_number</a> all have a <code>Digits</code> parameter which specifies how many binary digits the type stores. This corresponds to the number if bits in the value, <em>independent of the negated two's complement MSB</em>. It is the same value expressed in the <code>digits</code> member of <a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>. It is <em>not</em> the same as the width value found in types such as <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a> which are defined in <code>&lt;cstdint&gt;</code>.</p>
<p>One reason to choose digits instead of width is that this value indicates the range of a number consistently between signed and unsigned types. While confusing to anyone who is used to dealing in widths (e.g. <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a> vs <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint32_t</a>), it makes the implementation simpler and reduces the risk of overflow errors. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aall_8h_html"><div class="ttname"><a href="all_8h.html">all.h</a></div><div class="ttdoc">include-all header for the CNL numeric library; contains front page of user manual</div></div>
<div class="ttc" id="anamespacecnl_html_aae6e40278eb7ebee1c82a01c43a7bd7e"><div class="ttname"><a href="namespacecnl.html#aae6e40278eb7ebee1c82a01c43a7bd7e">cnl::elastic_scaled_integer</a></div><div class="ttdeci">scaled_integer&lt; elastic_integer&lt; Digits, Narrowest &gt;, Scale &gt; elastic_scaled_integer</div><div class="ttdoc">literal real number approximation that uses fixed-point arithmetic and auto-widens to avoid overflow</div><div class="ttdef"><b>Definition:</b> elastic_scaled_integer.h:41</div></div>
<div class="ttc" id="abasic_ostream_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a></div></div>
<div class="ttc" id="aendl_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a></div><div class="ttdeci">T endl(T... args)</div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdoc">STL namespace.</div></div>
<div class="ttc" id="anamespacecnl_html_ae512c45c8ddb3ca1289c9600fa6ca343"><div class="ttname"><a href="namespacecnl.html#ae512c45c8ddb3ca1289c9600fa6ca343">cnl::elastic_integer</a></div><div class="ttdeci">_impl::wrapper&lt; typename elastic_tag&lt; Digits, Narrowest &gt;::rep, elastic_tag&lt; Digits, Narrowest &gt; &gt; elastic_integer</div><div class="ttdoc">An integer type with auto-widening operators.</div><div class="ttdef"><b>Definition:</b> definition.h:39</div></div>
<div class="ttc" id="anamespacecnl_html_a9f25ddc2a68c2dd843efea8b3bc37d09"><div class="ttname"><a href="namespacecnl.html#a9f25ddc2a68c2dd843efea8b3bc37d09">cnl::scaled_integer</a></div><div class="ttdeci">_impl::wrapper&lt; Rep, Scale &gt; scaled_integer</div><div class="ttdoc">literal real number approximation that uses fixed-point arithmetic</div><div class="ttdef"><b>Definition:</b> definition.h:52</div></div>
<div class="ttc" id="anamespacecnl_html_a9c08b06a540e15fb300a460ce7a018a6"><div class="ttname"><a href="namespacecnl.html#a9c08b06a540e15fb300a460ce7a018a6">cnl::make_elastic_scaled_integer</a></div><div class="ttdeci">constexpr auto make_elastic_scaled_integer(constant&lt; Value &gt;) -&gt; elastic_scaled_integer&lt; std::max(digits_v&lt; constant&lt; Value &gt;&gt; - trailing_bits(Value), 1), power&lt; trailing_bits(Value)&gt;, Narrowest &gt;</div><div class="ttdoc">generate an elastic_scaled_integer object of given value</div><div class="ttdef"><b>Definition:</b> elastic_scaled_integer.h:65</div></div>
<div class="ttc" id="astructcnl_1_1power_html"><div class="ttname"><a href="structcnl_1_1power.html">cnl::power</a></div><div class="ttdoc">tag representing the scaling of an integer by a fixed factor</div><div class="ttdef"><b>Definition:</b> declaration.h:13</div></div>
<div class="ttc" id="anamespacecnl_1_1literals_html"><div class="ttname"><a href="namespacecnl_1_1literals.html">cnl::literals</a></div><div class="ttdoc">user-defined literals</div><div class="ttdef"><b>Definition:</b> literals.h:17</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
